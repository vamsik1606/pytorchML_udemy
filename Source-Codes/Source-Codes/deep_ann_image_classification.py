# -*- coding: utf-8 -*-
"""Deep ANN - Image Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1caWp0KB7u3d_Wms6TzlQ9DW2fXLnlp0B
"""

import torch
import torchvision
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
import matplotlib.pyplot as plt

train = torchvision.datasets.CIFAR10(root = './data',train = True, download = True,transform=transforms.ToTensor())
train

train[0]

test = torchvision.datasets.CIFAR10(root = './data',train = False, download = True,transform=transforms.ToTensor())
test

labels = [item[1] for item in train]
num_classes = len(set(labels))
print('Number of classes:', num_classes)

image, label = train[67]
print('Shape:',image.shape, '\Label:',label)

plt.imshow(image.T, interpolation='bicubic')  # the input of imshow should be (M,N,3) but we have (3,N,M)

train_loader = torch.utils.data.DataLoader(train, batch_size=100,shuffle=True)
test_loader = torch.utils.data.DataLoader(test, batch_size=100,shuffle=True)

"""**Neural Network Creation**"""

class ANN(nn.Module):
  def __init__(self,input_size,hidden_size1,hidden_size2,num_classes):
    super(ANN,self).__init__()
    self.fc1 = nn.Linear(input_size,hidden_size1,bias = True)
    self.relu = nn.ReLU()
    self.fc2 = nn.Linear(hidden_size1,hidden_size2, bias=True)
    self.relu = nn.ReLU()
    self.output = nn.Linear(hidden_size2,num_classes, bias=True)
  
  def forward(self,x):
    data = x.view(x.size(0),-1)
    data = self.fc1(data)
    data = self.relu(data)
    data = self.fc2(data)
    data = self.relu(data)
    data = self.output(data)
    return data

x = torch.randn(2,3,4)
out = x.view(x.size(0),-1)
print(x.shape)
print(out.shape)

input_size = 3*32*32
hidden_size1 = 120
hidden_size2 = 100
num_classes = 10
model = ANN(input_size,hidden_size1,hidden_size2,num_classes)

criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(),lr = 0.01)

"""**Training**"""

loss_list = []
accuracy_list = []

for epoch in range(50):
    epoch_loss = 0
    for images,labels in train_loader:
      outputs = model(images)
      loss = criterion(outputs,labels)

    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

    epoch_loss += loss.item()

  loss_list.append(epoch_loss/len(train_loader))

  with torch.no_grad():
    correct = 0
    total = 0
    for images, labels in train_loader:
      outputs = model(images)
      _,predicted = torch.max(outputs.data,1)  #[-1.4,+0.01,...]
      total += labels.size(0)
      correct += (predicted == labels).sum().item()
      accuracy = correct/total
      accuracy_list.append(accuracy)

    print('Epoch [{}/50] Training Accuracy: {:.4f}'.format(epoch+1, correct/total),'Loss: {:.4f}'.format(loss_list[-1]))

x = range(50)
plt.plot(x,loss_list)
plt.xlabel('iterations')
plt.ylabel('Loss')
plt.show()

#_,predicted = torch.max(outputs.data,1)
# outputs.data

"""**Testing**"""

with torch.no_grad():
  correct = 0
  total = 0
  for images, labels in test_loader:
    outputs = model(images)
    _,predicted = torch.max(outputs.data,1)
    total += labels.size(0)
    correct += (predicted == labels).sum().item()
  print('Test Accuracy: {:.4f}'.format(correct/total))

"""**Confusion Matrix**"""

from sklearn.metrics import confusion_matrix

model.eval()
with torch.no_grad():
  correct = 0
  total = 0
  confusion_matrix = torch.zeros(10,10)
  for images, labels in test_loader:
    outputs = model(images)
    _,predicted = torch.max(outputs.data,1)
    total += labels.size(0)
    correct += (predicted == labels).sum().item()
    for i,j in zip(predicted,labels):
      confusion_matrix[i][j] += 1
confusion_matrix = confusion_matrix.numpy().astype(int)
print('Confusion Matrix')
print(confusion_matrix)